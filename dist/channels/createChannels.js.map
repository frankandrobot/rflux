{"version":3,"sources":["channels/createChannels.js"],"names":["bindActionFunctions","_createChannel","createChannels","_bindActionFunctionToAppDispatcher","actionFunction","AppDispatcher","emit","ActionTypes","ActionFunctions","Object","keys","reduce","channelActions","action","_bindActionObservables","ActionObservables","total","observable","assign","channelObservable","_createChannelStateObservable","channel","Reducers","filter","x","scan","stateWithSideEffects","reducer","actionType","Error","endOfSideEffects","payload","state","initialState","_createEndOfActionsObservables","observables","map","forEach","console","warn","stateWithSideEffectsObservable","stateObservable","name","actions","rawChannels","args","s"],"mappings":"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","file":"createChannels.js","sourcesContent":["import cast from '../internal/cast'\nimport assert from '../internal/assert'\nimport checkUnique from '../internal/checkUnique'\n\nimport StateWithSideEffects from './StateWithSideEffects'\nimport {state} from './StateWithSideEffects'\n\n\nfunction _bindActionFunctionToAppDispatcher(actionFunction) {\n\n  return AppDispatcher =>\n    (...args) => AppDispatcher.emit({...actionFunction(...args)})\n}\n\n/**\n * Takes a map of ActionFunctions indexed by ActionType and binds each to the\n * AppDispatcher. That is, when a bound function is called, it automatically\n * dispatches its message to the channel.\n *\n * **Note:**\n * 1. This method is actually a higher order function. It returns a function\n *    that accepts the AppDispatcher object as a parameter. This way, the\n *    AppDispatcher is not hard-coded dependency.\n *\n * @param {Map<string,boolean>} ActionTypes\n * @param {Map<ActionType,Function>} ActionFunctions\n * @returns {Function} a function that binds the action functions to the app dispatcher\n * @private\n */\nexport function bindActionFunctions(ActionTypes, ActionFunctions) {\n\n  return AppDispatcher =>\n\n    Object.keys(ActionTypes).reduce(\n      (channelActions, action) => ({\n        ...channelActions,\n        [action]: _bindActionFunctionToAppDispatcher(ActionFunctions[action])(AppDispatcher)\n      }),\n      {}\n    )\n}\n\n/**\n * @deprecated You rarely (really) need a *pre-bound* selector (emphasis:\n * \"pre-bound\"). For this reason, these are deprecated.\n *\n * Takes a map of ActionObservables *not necessarily indexed by ActionType* and binds each\n * to the ChannelStateObservable. The ChannelStateObservable is the channel's state,\n * wrapped in a Kefir stream (otherwise known as an *observable*).\n *\n * Since the ChannelStateObservable represents the state, an ActionObservable is a\n * way of observing (aka \"selecting\") arbitrary parts of the state tree.\n *\n * **Note:**\n * 1. This method is actually a higher order function. It returns a function\n *    that accepts a ChannelStateObservable object as a parameter. This way, the\n *    ChannelStateObservable is not hard-coded dependency.\n *\n * TODO global rename ActionObservable => SelectionObservable\n *\n * @param {Map<string,Observable>} ActionObservables\n * @returns {Function} a function that binds the action observables to the channel observable\n * @private\n */\nfunction _bindActionObservables(ActionObservables) {\n\n  return channelObservable =>\n\n    Object.keys(ActionObservables).reduce(\n      (total, observable) => Object.assign(\n        total,\n        {[observable]: ActionObservables[observable](channelObservable)}\n      ),\n      {}\n    )\n}\n\n/**\n * Creates the channel's state observable using the given channel name.\n *\n * When an action comes in, it will call the corresponding reducer with the payload,\n * and pass the new state to the observable.\n *\n * Every reducer is called with these parameters:\n * 1. the current state\n * 2. the action payload\n * 3. a `endOfSideEffects` function that can be used to report the end of all the\n * side effects.\n *\n * In addition to updating the state, every reducer can also dispatch side\n * effects---which are just messages that are handled by other reducers or sagas. By\n * using the result of the `endOfSideEffects` function as the last side effect, it is\n * possible to tell when the entire reducer workflow completes... or so that's the\n * idea.\n *\n * Each reducer has this signature:\n *\n * ```\n * (state:ChannelState, payload:Payload, endOfSideEffects:Payload => Message)\n * => StateWithSideEffects\n * ```\n *\n * TODO sideEffectResult may not actually fire correctly, specially when side effects\n * are handled by async sagas.\n *\n * **Notes:**\n * 1. Every ActionType must have a corresponding Reducer.\n * 2. This method is actually a higher order function. It returns a function\n *    that accepts an AppDispatcher object as a parameter. This way, the\n *    AppDispatcher is not hard-coded dependency.\n *\n * @param {string} channel\n * @param {Map<ActionType,Function>} Reducers\n * @returns {Function} a function that creates the channel's state observable.\n * @private\n */\nfunction _createChannelStateObservable(channel, Reducers) {\n\n  return AppDispatcher =>\n\n    AppDispatcher\n      .filter(x => x && x.channel === channel)\n      .scan(\n        (stateWithSideEffects, action) => {\n\n          const reducer = Reducers[action.actionType]\n\n          if (!reducer) {\n            throw new Error(`Channel ${channel} does not support ${action.actionType}`)\n          }\n\n          const endOfSideEffects = payload => ({\n            channel: `${channel}Result`,\n            actionType: `${action.actionType}Result`,\n            payload\n          })\n\n          // always return a StateWithSideEffects (code hardening)\n          return cast(\n            reducer(stateWithSideEffects.state, action.payload, endOfSideEffects),\n            StateWithSideEffects\n          )\n        },\n        state(Reducers.initialState || {})\n        )\n}\n\n\n/**\n * The idea is that you can use these observables to observe the end of a reducer +\n * side effects.\n * @param {string} channel\n * @param {Map<string,*>} ActionTypes\n * @returns {Function} function that binds AppDispatcher to the observables\n * @private\n */\nfunction _createEndOfActionsObservables(channel, ActionTypes) {\n\n  return AppDispatcher =>\n\n    Object.keys(ActionTypes).reduce(\n      (observables, action) => Object.assign(\n        observables,\n        {\n          [`${action}ResultObservable`]:\n            AppDispatcher\n              .filter(x =>\n              x.channel === `${channel}Result` && x.actionType === `${action}Result`)\n              .map(x => x.payload)\n        }\n      ),\n      {}\n    )\n}\n\n/* eslint-disable no-console */\n/**\n * The channel consists of\n * - the channel name\n * - the state observable\n * - bound (aka \"live\") action functions\n * - bound state selectors (which will probably be deprecated in a future release)\n *\n * It is created from a map of the ActionTypes. Each ActionType has a corresponding\n * reducer, which handles incoming messages. Each ActionType also has a corresponding\n * ActionFunction that's used to dispatch messages.\n *\n * One catch is that the *names* of the ActionFunctions and the ActionObservables must\n * be globally unique. This isn't hard to achieve as long as you:\n *\n * 1. use the channel name in the action/observable. Ex: createDoc\n * 2. use the word \"observable\" in the observables. Ex: docObservable\n *\n * @param {Object} opts\n * @param {string} opts.channel\n * @param {Map<string,*>} opts.ActionTypes - map of action type constants\n * @param {Map<ActionType,Function>} opts.Reducers - map of reducers, indexed by\n * ActionType. Additionally, reducers have an `initialState` property.\n * @param {Map<ActionType,Function>} opts.ActionFunctions - map of action functions,\n * indexed by ActionType\n * @param {Map<string,Function>} opts.ActionObservables (optional) - higher order\n * functions that take the ChannelStateObservable as input and return an observable that\n * selects parts of the state tree. **This will probably be deprecated.**\n * @returns {Function} that binds the channel to the app dispatcher\n * @private\n */\nexport function _createChannel(\n  {channel, ActionTypes, Reducers, ActionFunctions, ActionObservables}) {\n\n  ActionObservables = ActionObservables || {}\n\n  assert(typeof channel === 'string', 'Needs a channel and it needs to be a string')\n  assert(ActionTypes, 'Need ActionTypes')\n  assert(Reducers, 'Need Reducers')\n  assert(ActionFunctions, 'Need action functions')\n\n  //every action must have an action function and a reducer\n  Object.keys(ActionTypes).forEach(action => {\n    assert(\n      ActionFunctions[action],\n      `Channel ${channel} is missing action function \"${action}\"`\n    )\n    assert(Reducers[action], `Channel ${channel} is missing reducer \"${action}\"`)\n  })\n\n  //need an initial state; otherwise defaults to {}\n  if (!Reducers.initialState) {\n    console.warn(`Channel ${channel} doesn't have initialState`)\n  }\n\n  return ({AppDispatcher}) => {\n\n    const stateWithSideEffectsObservable =\n      _createChannelStateObservable(channel, Reducers)(AppDispatcher)\n    const stateObservable = stateWithSideEffectsObservable.map(x => x.state)\n\n    return {\n      name: channel,\n      stateWithSideEffectsObservable,\n      actions: {\n        ...bindActionFunctions(ActionTypes, ActionFunctions)(AppDispatcher),\n      },\n      observable: {\n        [channel]: stateObservable,\n      },\n      channel: {\n        // @deprecated\n        ..._bindActionObservables(ActionObservables)(stateObservable),\n        // @deprecated\n        ..._createEndOfActionsObservables(channel, ActionTypes)(AppDispatcher),\n      }\n    }\n  }\n}\n\n\nexport default function createChannels({rawChannels, ...args}) {\n  checkUnique(rawChannels, 'channel', 'Cannot have two channels with the same name');\n  return rawChannels.map(s => _createChannel(s)({...args}))\n}\n"]}