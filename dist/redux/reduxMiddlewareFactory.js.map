{"version":3,"sources":["redux/reduxMiddlewareFactory.js"],"names":["middlewareFactory","dispatch","rawMiddleware","state","store","getState","middleware","map","__middleware","setState","_state","attachMiddleware","AppDispatcher","AppDispatcherObs","flatMap","reduce","chain","_middleware","transformedAction","action","allowContinue","next","_action","filter","constant","Object","assign","emit"],"mappings":";;;;;kBAGwBA,iB;;AAHxB;;;;;;AAGe,SAASA,iBAAT,OAAsD;AAAA,MAA1BC,QAA0B,QAA1BA,QAA0B;AAAA,MAAhBC,aAAgB,QAAhBA,aAAgB;;;AAEnE,MAAIC,QAAQ,IAAZ;AACA,MAAMC,QAAQ;AACZH,sBADY;AAEZI,cAAU;AAAA,aAAMF,KAAN;AAAA;AAFE,GAAd;AAIA,MAAMG,aAAaJ,cAAcK,GAAd,CAAkB;AAAA,WAAgBC,aAAaJ,KAAb,CAAhB;AAAA,GAAlB,CAAnB;;AAEA,SAAO;AACLK,cAAU;AAAA,aAAUN,QAAQO,MAAlB;AAAA,KADL;;AAGLC,oBAHK,mCAG6B;AAAA,UAAhBC,aAAgB,SAAhBA,aAAgB;;AAChC,UAAMC;AACJ;AACA;AACA;AACAD,oBACCE,OADD,CACS;AAAA,eACPR,WAAWS,MAAX,CACE,UAACC,KAAD,EAAQC,WAAR,EAAwB;AACtB,cAAIC,oBAAoBC,MAAxB;AACA,cAAIC,gBAAgB,KAApB;AACA;AACA;AACA,cAAMC,OAAO,SAAPA,IAAO,UAAW;AACtBH,gCAAoBI,OAApB;AACAF,4BAAgB,IAAhB;AACD,WAHD;;AAKA,iBAAOJ,MACJO,MADI,CACG,mBAAW;AACjBN,wBAAYI,IAAZ,EAAkBC,OAAlB;AACA;AACA,mBAAOF,aAAP;AACD,WALI;AAML;AANK,WAOJb,GAPI,CAOA;AAAA,mBAAMW,iBAAN;AAAA,WAPA,CAAP;AAQD,SAnBH,EAoBE,gBAAMM,QAAN,CAAeL,MAAf,CApBF,CADO;AAAA,OADT,CAJF;;AA8BA;AACA;AACA;AACAM,aAAOC,MAAP,CAAcb,gBAAd,EAAgC,EAACc,MAAM;AAAA,iBAAaf,cAAce,IAAd,gCAAb;AAAA,SAAP,EAAhC;;AAEA,aAAOd,gBAAP;AACD;AAxCI,GAAP;AA0CD","file":"reduxMiddlewareFactory.js","sourcesContent":["import kefir from 'kefir'\n\n\nexport default function middlewareFactory({dispatch, rawMiddleware}) {\n\n  let state = null\n  const store = {\n    dispatch,\n    getState: () => state\n  }\n  const middleware = rawMiddleware.map(__middleware => __middleware(store))\n\n  return {\n    setState: _state => state = _state,\n\n    attachMiddleware({AppDispatcher}) {\n      const AppDispatcherObs =\n        // this injects the middleware into the AppDispatcher. Middleware can stop propagation of events\n        // to observables by not calling \"next(action)\". Middleware can also transform actions or dispatch\n        // their own actions.\n        AppDispatcher\n        .flatMap(action =>\n          middleware.reduce(\n            (chain, _middleware) => {\n              let transformedAction = action\n              let allowContinue = false\n              // the \"next\" action doesn't actually do anything.... it just tells the chain of\n              // filters to continue. Also allows the middleware to transfom the action\n              const next = _action => {\n                transformedAction = _action\n                allowContinue = true\n              }\n\n              return chain\n                .filter(_action => {\n                  _middleware(next)(_action)\n                  // stop if next not called\n                  return allowContinue\n                })\n                // transform action (if requested)\n                .map(() => transformedAction)\n            },\n            kefir.constant(action)\n          )\n        )\n\n      // Yuck. Turn the observer into a dispatcher by adding an emit method that dispatches events into\n      // the *original* AppDispatcher bus. Recall that the AppDispatcher is a bus (an observable with an emit\n      // method).\n      Object.assign(AppDispatcherObs, {emit: (...args) => AppDispatcher.emit(...args)})\n\n      return AppDispatcherObs\n    }\n  }\n}\n"]}