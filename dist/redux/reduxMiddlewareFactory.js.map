{"version":3,"sources":["redux/reduxMiddlewareFactory.js"],"names":["reduxMiddlewareFactory","AppDispatcher","rawMiddleware","state","reduxStore","dispatch","emit","channel","actionType","args","type","payload","getState","middleware","map","__middleware","setState","_state","appDispatcher","AppDispatcherObs","flatMap","reduce","chain","_middleware","transformedReduxAction","allowContinue","next","reduxAction","filter","constant","rfluxAction","Object","assign"],"mappings":";;;;;;;;kBAewBA,sB;;AAfxB;;;;AAEA;;;;AAEA;;;;;;AAGA;;;;;;;;AAQe,SAASA,sBAAT,OAAgE;AAAA,MAA/BC,aAA+B,QAA/BA,aAA+B;AAAA,MAAhBC,aAAgB,QAAhBA,aAAgB;;;AAE7E,wBAAOD,aAAP,EAAsB,uBAAtB;AACA,wBAAOC,aAAP,EAAsB,oBAAtB;;AAEA,MAAIC,QAAQ,IAAZ;AACA,MAAMC,aAAa;AACjB;AACAC,cAAU;AAAA,aAAQJ,cAAcK,IAAd,CAAmB;AACnCC,2CADmC;AAEnCC,oBAAY,CAACC,QAAQ,EAAT,EAAaC,IAFU;AAGnCC,iBAASF,QAAQ;AAHkB,OAAnB,CAAR;AAAA,KAFO;AAOjBG,cAAU;AAAA,aAAMT,KAAN;AAAA;AAPO,GAAnB;AASA,MAAMU,aAAaX,cAAcY,GAAd,CAAkB;AAAA,WAAgBC,aAAaX,UAAb,CAAhB;AAAA,GAAlB,CAAnB;;AAEA,SAAO;AACLY,cAAU;AAAA,aAAUb,QAAQc,MAAlB;AAAA,KADL;;AAGL;;;;AAIAC,iBAPK,2BAOW;AACd,UAAMC,mBACJlB,cACGmB,OADH,CACW;AAAA,eACPP,WACGQ,MADH,CAEI,UAACC,KAAD,EAAQC,WAAR,EAAwB;AACtB,cAAIC,+BAAJ;AACA,cAAIC,gBAAgB,KAApB;AACA;AACA;AACA;AACA,cAAMC,OAAO,SAAPA,IAAO,cAAe;AAC1BF,qCAAyBG,WAAzB;AACAF,4BAAgB,IAAhB;AACD,WAHD;;AAKA,iBAAOH,MACJM,MADI,CACG,uBAAe;AACrBL,wBAAYG,IAAZ,EAAkBC,WAAlB;AACA;AACA,mBAAOF,aAAP;AACD,WALI;AAML;AANK,WAOJX,GAPI,CAOA;AAAA,mBAAMU,sBAAN;AAAA,WAPA,CAAP;AAQD,SArBL,EAsBI,gBAAMK,QAAN,CACE,OAAOC,YAAYnB,OAAnB,KAA+B,WAA/B,GAA6C,EAA7C,GAAkDmB,YAAYnB,OADhE,CAtBJ,EA0BGG,GA1BH,CA0BO;AAAA,8BAAoBgB,WAApB,IAAiCnB,SAASgB,WAA1C;AAAA,SA1BP,CADO;AAAA,OADX,CADF;;AAgCA;AACA;AACA;AACAI,aAAOC,MAAP,CAAcb,gBAAd,EAAgC,EAACb,MAAM;AAAA,iBAAaL,cAAcK,IAAd,gCAAb;AAAA,SAAP,EAAhC;;AAEA,aAAOa,gBAAP;AACD;AA9CI,GAAP;AAgDD","file":"reduxMiddlewareFactory.js","sourcesContent":["import kefir from 'kefir'\n\nimport assert from '../internal/assert'\n\nimport reduxChannelName from './reduxChannelName'\n\n\n/**\n * This injects the middleware into the AppDispatcher. Middleware can stop propagation\n * of events to observables by not calling \"next(action)\". Middleware can also\n * transform actions or dispatch their own actions.\n * @param {kefirEmitter} AppDispatcher\n * @param {middleware[]} rawMiddleware\n * @returns {MiddlewareFactory} factory\n */\nexport default function reduxMiddlewareFactory({AppDispatcher, rawMiddleware}) {\n\n  assert(AppDispatcher, 'Need an AppDispatcher')\n  assert(rawMiddleware, 'Need rawMiddleware')\n\n  let state = null\n  const reduxStore = {\n    // transform redux-formatted message to rflux\n    dispatch: args => AppDispatcher.emit({\n      channel: reduxChannelName,\n      actionType: (args || {}).type,\n      payload: args || {}\n    }),\n    getState: () => state\n  }\n  const middleware = rawMiddleware.map(__middleware => __middleware(reduxStore))\n\n  return {\n    setState: _state => state = _state,\n\n    /**\n     * This AppDispatcher is middleware aware.\n     * @returns {kefirEmitter} the AppDispatcher\n     **/\n    appDispatcher() {\n      const AppDispatcherObs =\n        AppDispatcher\n          .flatMap(rfluxAction =>\n            middleware\n              .reduce(\n                (chain, _middleware) => {\n                  let transformedReduxAction\n                  let allowContinue = false\n                  // the \"next\" action doesn't actually do anything.... it just tells the\n                  // chain of filters to continue. Also allows the middleware to transfom\n                  // the payload\n                  const next = reduxAction => {\n                    transformedReduxAction = reduxAction\n                    allowContinue = true\n                  }\n\n                  return chain\n                    .filter(reduxAction => {\n                      _middleware(next)(reduxAction)\n                      // stop if next not called\n                      return allowContinue\n                    })\n                    // transform action (if requested)\n                    .map(() => transformedReduxAction)\n                },\n                kefir.constant(\n                  typeof rfluxAction.payload === 'undefined' ? {} : rfluxAction.payload\n                )\n              )\n              .map(reduxAction => ({...rfluxAction, payload: reduxAction}))\n          )\n\n      // Yuck. Turn the observer into a dispatcher by adding an emit method that\n      // dispatches events into the *original* AppDispatcher bus. Recall that the\n      // AppDispatcher is a bus (an observable with an emit method).\n      Object.assign(AppDispatcherObs, {emit: (...args) => AppDispatcher.emit(...args)})\n\n      return AppDispatcherObs\n    }\n  }\n}\n"]}