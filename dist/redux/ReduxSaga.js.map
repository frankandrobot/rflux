{"version":3,"sources":["redux/ReduxSaga.js"],"names":["reduxSagaMiddleware","fakeAppDispatcher","sagaMessageBus","callObservable","filter","action","map","payload","flatMap","callId","result","fn","args","resultObservable","constant","rslt","onValue","undefined","channel","ActionTypes","SagaActionFunctions","SagaHandlers","Object","keys","forEach","setTimeout","type","emit","next","ReduxSaga","store","dispatch","take","actionType"],"mappings":"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","file":"ReduxSaga.js","sourcesContent":["import assert from '../internal/assert'\n\nimport Kefir from 'kefir'\n\nimport kefirEmitter from '../utils/kefirEmitter'\nimport isObservable from '../internal/isObservable'\nimport uuid from '../internal/uuid'\n\n\nexport const fakeAppDispatcher = kefirEmitter()\nexport const sagaMessageBus = kefirEmitter()\n\n/**\n * Call the action and return the result (as an observable)\n */\nconst callObservable = sagaMessageBus\n  .filter(action => action.action === 'CALL')\n  .map(action => action.payload)\n  .flatMap(action => {\n\n    const callId = action.callId\n    const result = action.fn(...action.args)\n    const resultObservable = isObservable(result) ? result : Kefir.constant(result)\n\n    return resultObservable.map(rslt => ({callId, rslt}))\n  })\n  .onValue(() => undefined)\n\n/**\n * @param {String} channel\n * @param {Map} ActionTypes - map whose keys are the names of the side effects\n * @param {Map} SagaActionFunctions - (optional) map of action functions\n * @param {Map} SagaHandlers - map of handler functions\n * @returns {Object} redux middleware\n */\nexport function reduxSagaMiddleware(channel, {ActionTypes, SagaActionFunctions, SagaHandlers}) {\n\n  assert(typeof channel === 'string', 'Needs a channel and it needs to be a string')\n  assert(ActionTypes, 'Need ActionTypes')\n  assert(SagaHandlers, 'Need SagaHandlers')\n\n  //every side effect must map to an action function and handler\n  Object.keys(ActionTypes).forEach(action => {\n    if (SagaActionFunctions) {\n      assert(SagaActionFunctions[action], `Channel ${channel} is missing side effect action function \"${action}\"`)\n    }\n    assert(SagaHandlers[action], `Channel ${channel} is missing side effect handler \"${action}\"`)\n  })\n\n  SagaActionFunctions = SagaActionFunctions || {}\n\n  return () => next => action => {\n\n    setTimeout(() => SagaHandlers[action.type](action), 0)\n    setTimeout(() => fakeAppDispatcher.emit(action), 0)\n\n    return next(action)\n  }\n}\n\nexport class ReduxSaga {\n\n  constructor(store) {\n\n    this.store = store\n  }\n\n  put(action) {\n    setTimeout(() => this.store.dispatch(action), 0)\n\n    return Kefir.constant(action) // streamified so we can chain together\n  }\n\n  call(fn, ...args) {\n\n    const callId = uuid()\n\n    setTimeout(() => sagaMessageBus.emit({action: 'CALL', payload: {fn, args, callId}}), 0)\n\n    return callObservable.filter(fn => fn.callId === callId).map(fn => fn.rslt).take(1)\n  }\n\n  listen(channel, actionType) {\n\n    return fakeAppDispatcher\n      .filter(action => action.channel === channel && action.actionType === actionType)\n      .map(action => action.payload)\n  }\n}\n"]}