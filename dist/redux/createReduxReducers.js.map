{"version":3,"sources":["redux/createReduxReducers.js"],"names":["createReduxReducers","_createReduxReducerStateObservable","channel","Reducers","reducerKeys","Object","keys","AppDispatcher","filter","x","scan","state","action","newFullState","i","length","reducerKey","reducer","newState","payload","reduce","initialState","assign","undefined","combinedStateObservable","map","reducerStateObservable","combinedState","skipDuplicates","prev","next","name","stateWithSideEffectsObservable","reducerState","observable"],"mappings":";;;;;kBAoEwBA,mB;;AApExB;;;;AAEA;;AAEA;;;;;;;;AAGA,SAASC,kCAAT,CAA4CC,OAA5C,EAAqDC,QAArD,EAA+D;;AAE7D,MAAMC,cAAcC,OAAOC,IAAP,CAAYH,QAAZ,CAApB;;AAEA,SAAO;AAAA,WAELI,cACGC,MADH,CACU;AAAA,aAAKC,KAAKA,EAAEP,OAAF,KAAcA,OAAxB;AAAA,KADV,EAEGQ,IAFH,CAGI,UAACC,KAAD,EAAQC,MAAR,EAAmB;;AAEjB,UAAMC,eAAe,EAArB;;AAEA,WAAI,IAAIC,IAAE,CAAV,EAAaA,IAAEV,YAAYW,MAA3B,EAAmCD,GAAnC,EAAwC;AACtC,YAAME,aAAaZ,YAAYU,CAAZ,CAAnB;AACA,YAAMG,UAAUd,SAASa,UAAT,CAAhB;AACA,YAAME,WAAWD,QAAQN,MAAMK,UAAN,CAAR,EAA2BJ,OAAOO,OAAlC,CAAjB;;AAEAN,qBAAaG,UAAb,IAA2BE,QAA3B;AACD;AACD;AACA;AACA,aAAOL,YAAP;AACD,KAjBL;AAkBI;AACA;AACAT,gBAAYgB,MAAZ,CACE,UAACC,YAAD,EAAeL,UAAf;AAAA,aAA8BX,OAAOiB,MAAP,CAC5BD,YAD4B,sBAE1BL,UAF0B,EAEbb,SAASa,UAAT,EAAqBO,SAArB,EAAgC,EAAhC,CAFa,EAA9B;AAAA,KADF,EAKE,EALF,CApBJ,CAFK;AAAA,GAAP;AA8BD;;AAGD;;;;;;;;;;;;;;;;;;;;;;;;AAwBe,SAASvB,mBAAT,OAAwD;AAAA,MAA1BG,QAA0B,QAA1BA,QAA0B;AAAA,MAAhBI,aAAgB,QAAhBA,aAAgB;;;AAErE,wBAAOJ,QAAP,EAAiB,eAAjB;;AAEA,MAAMqB,0BACJvB,+DAAqDE,QAArD,EAA+DI,aAA/D,CADF;;AAGA,SAAOF,OAAOC,IAAP,CAAYH,QAAZ,EACJsB,GADI,CACA,sBAAc;AACjB,QAAMC,yBAAyBF,wBAC5BC,GAD4B,CACxB;AAAA,aAAiBE,cAAcX,UAAd,CAAjB;AAAA,KADwB;AAE7B;AACA;AAH6B,KAI5BY,cAJ4B,CAIb,UAACC,IAAD,EAAOC,IAAP;AAAA,aAAgBD,QAAQC,IAAxB;AAAA,KAJa,CAA/B;;AAMA,WAAO;AACLC,YAAMf,UADD;AAELgB,sCACEN,uBAAuBD,GAAvB,CAA2B;AAAA,eAAgB,iCAAMQ,YAAN,CAAhB;AAAA,OAA3B,CAHG;AAILC,sCACGlB,UADH,EACgBU,sBADhB,CAJK;AAOLxB,eAAS;AAPJ,KAAP;AASD,GAjBI,CAAP;AAkBD","file":"createReduxReducers.js","sourcesContent":["import assert from '../internal/assert'\n\nimport {state} from '../channels/StateWithSideEffects'\n\nimport reduxChannelName from './reduxChannelName'\n\n\nfunction _createReduxReducerStateObservable(channel, Reducers) {\n\n  const reducerKeys = Object.keys(Reducers)\n\n  return AppDispatcher =>\n\n    AppDispatcher\n      .filter(x => x && x.channel === channel)\n      .scan(\n        (state, action) => {\n\n          const newFullState = {}\n\n          for(let i=0; i<reducerKeys.length; i++) {\n            const reducerKey = reducerKeys[i]\n            const reducer = Reducers[reducerKey]\n            const newState = reducer(state[reducerKey], action.payload)\n\n            newFullState[reducerKey] = newState\n          }\n          // note how this returns a normal JS object. That means \"state\" in this\n          // stream is just a normal JS object.\n          return newFullState\n        },\n        // the assumption is that if you invoke the reducer with no params, you will\n        // get back the initial state.\n        reducerKeys.reduce(\n          (initialState, reducerKey) => Object.assign(\n            initialState,\n            {[reducerKey]: Reducers[reducerKey](undefined, {})}\n          ),\n          {}\n        )\n      )\n}\n\n\n/**\n * Creates a special channel for redux reducers. The main differences between this and\n * `createChannels` are:\n *\n * 1. `createChannels` assumes a single reducer per action type. `createReduxReducers`\n *    passes all actions to *every* reducer, as per the redux style.\n * 2. `createChannels` maps each channel to a single top-level state property.\n *    `createReduxReducers` maps every reducer to a top-level state property. But\n *     internally, all messages flow through a single redux channel.\n *\n * ## Limitations\n *\n * Currently, `redux#combineReducers` is not supported.\n *\n * ## Message Dispatching\n *\n * To pass a message to a redux reducer from an rflux app, use this format:\n * - channel:String = reduxChannelName (see ./reduxChannelName)\n * - actionType:String\n * - payload: {//actual redux action }\n *\n * @param {Map<String,Function>} Reducers\n * @returns {Function} the redux reducers channel\n */\nexport default function createReduxReducers({Reducers, AppDispatcher}) {\n\n  assert(Reducers, 'Need Reducers')\n\n  const combinedStateObservable =\n    _createReduxReducerStateObservable(reduxChannelName, Reducers)(AppDispatcher)\n\n  return Object.keys(Reducers)\n    .map(reducerKey => {\n      const reducerStateObservable = combinedStateObservable\n        .map(combinedState => combinedState[reducerKey])\n        // check that objects point to the same thing\n        // eslint-disable-next-line eqeqeq\n        .skipDuplicates((prev, next) => prev == next)\n\n      return {\n        name: reducerKey,\n        stateWithSideEffectsObservable:\n          reducerStateObservable.map(reducerState => state(reducerState)),\n        observable: {\n          [reducerKey]: reducerStateObservable,\n        },\n        channel: {}\n      }\n    })\n}\n"]}