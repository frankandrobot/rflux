{"version":3,"sources":["createSagas.js"],"names":[],"mappings":";;;;;QAMgB,e,GAAA,e;kBAiCQ,W;;AAvCxB;;;;AAEA;;AACA;;;;;;AAGO,SAAS,eAAT,CAAyB,OAAzB,EAAkC,QAAlC,EAA4C,WAA5C,EAAyD;;AAE9D,SAAO;AAAA,WAEL,cACG,MADH,CACU;AAAA,aAAK,EAAE,OAAF,KAAc,OAAd,IAAyB,EAAE,UAAF,KAAiB,QAA/C;AAAA,KADV,EAEG,OAFH,CAEW;AAAA,aAAK,YAAY,EAAE,OAAd,CAAL;AAAA,KAFX,CAFK;AAAA,GAAP;AAKD;;AAED,SAAS,iBAAT,CAA2B,OAA3B,EAAoC,KAApC,EAA2C,YAA3C,EAAyD;;AAEvD,SAAO;AAAA,WAEL,OAAO,IAAP,CAAY,KAAZ,EAAmB,MAAnB,CACE,UAAC,WAAD,EAAc,WAAd,EAA8B;AAC5B,UAAM,UAAU,aAAa,WAAb,CAAhB;AACA,UAAM,aAAa,gBAAgB,OAAhB,EAAyB,WAAzB,EAAsC,OAAtC,EAA+C,aAA/C,CAAnB;;AAEA,aAAO,OAAO,MAAP,CAAc,WAAd,sBAA6B,WAA7B,EAA2C,UAA3C,EAAP;AACD,KANH,EAOE,EAPF,CAFK;AAAA,GAAP;AAWD;;;;;;;;;;;AAWc,SAAS,WAAT,CAAqB,OAArB,QAA0E;AAAA,MAA3C,KAA2C,QAA3C,KAA2C;AAAA,MAApC,mBAAoC,QAApC,mBAAoC;AAAA,MAAf,YAAe,QAAf,YAAe;;;AAEvF,wBAAO,OAAO,OAAP,KAAmB,QAA1B,EAAoC,6CAApC;AACA,wBAAO,KAAP,EAAc,YAAd;AACA,wBAAO,YAAP,EAAqB,mBAArB;;;AAGA,SAAO,IAAP,CAAY,KAAZ,EAAmB,OAAnB,CAA2B,kBAAU;AACnC,QAAI,mBAAJ,EAAyB;AACvB,4BAAO,oBAAoB,MAApB,CAAP,eAA+C,OAA/C,iDAAkG,MAAlG;AACD;AACD,0BAAO,aAAa,MAAb,CAAP,eAAwC,OAAxC,yCAAmF,MAAnF;AACD,GALD;;AAOA,wBAAsB,uBAAuB,EAA7C;;AAEA,SAAO;AAAA,WAAkB;AACvB,YAAM,OADiB;AAEvB,mBAAa,kBAAkB,OAAlB,EAA2B,KAA3B,EAAkC,YAAlC,EAAgD,aAAhD,CAFU;AAGvB,uBAAiB,sCAAoB,KAApB,EAA2B,mBAA3B,EAAgD,aAAhD;AAHM,KAAlB;AAAA,GAAP;AAKD","file":"createSagas.js","sourcesContent":["import assert from './support/assert'\n\nimport {result} from './Saga'\nimport {bindActionFunctions} from './createStore'\n\n\nexport function bindSagaHandler(channel, sagaName, sagaHandler) {\n\n  return AppDispatcher =>\n  \n    AppDispatcher\n      .filter(x => x.channel === channel && x.actionType === sagaName)\n      .flatMap(x => sagaHandler(x.payload))\n}\n\nfunction _bindSagaHandlers(channel, Sagas, SagaHandlers) {\n\n  return AppDispatcher =>\n\n    Object.keys(Sagas).reduce(\n      (observables, handlerName) => {\n        const handler = SagaHandlers[handlerName]\n        const observable = bindSagaHandler(channel, handlerName, handler)(AppDispatcher)\n\n        return Object.assign(observables, {[handlerName]: observable})\n      },\n      {}\n    )\n}\n\n/**\n  * SideEffectActionFunctions are optional but if you pass these,\n  * then every SideEffect must have a corresponding action function.\n  *\n  * @param channel\n  * @param Sagas - map whose keys are the names of the side effects\n  * @param SagaActionFunctions - (optional) map of action functions\n  * @param SagaHandlers - map of handler functions\n  */\nexport default function createSagas(channel, {Sagas, SagaActionFunctions, SagaHandlers}) {\n\n  assert(typeof channel === 'string', 'Needs a channel and it needs to be a string')\n  assert(Sagas, 'Need Sagas')\n  assert(SagaHandlers, 'Need SagaHandlers')\n\n  //every side effect must map to an action function and handler\n  Object.keys(Sagas).forEach(action => {\n    if (SagaActionFunctions) {\n      assert(SagaActionFunctions[action], `Channel ${channel} is missing side effect action function \"${action}\"`)\n    }\n    assert(SagaHandlers[action], `Channel ${channel} is missing side effect handler \"${action}\"`)\n  })\n\n  SagaActionFunctions = SagaActionFunctions || {}\n\n  return AppDispatcher => ({\n    name: channel,\n    observables: _bindSagaHandlers(channel, Sagas, SagaHandlers)(AppDispatcher),\n    actionFunctions: bindActionFunctions(Sagas, SagaActionFunctions)(AppDispatcher)\n  })\n}\n"]}