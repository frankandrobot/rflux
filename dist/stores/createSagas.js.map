{"version":3,"sources":["stores/createSagas.js"],"names":["bindSagaHandler","createSagas","channel","sagaName","sagaHandler","AppDispatcher","filter","x","actionType","flatMap","payload","map","setTimeout","emit","result","_bindSagaHandlers","ActionTypes","SagaHandlers","Object","keys","reduce","observables","saga","handler","observable","assign","_bindSagaResultObservables","sagas","SagaActionFunctions","SagaHandlersFn","sagaInterface","forEach","action","name","actionFunctions","resultObservables"],"mappings":"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","file":"createSagas.js","sourcesContent":["import assert from '../internal/assert'\n\nimport {bindActionFunctions} from './createStore'\n\n\nexport function bindSagaHandler(channel, sagaName, sagaHandler) {\n\n  return AppDispatcher =>\n\n    AppDispatcher\n      .filter(x => x.channel === channel && x.actionType === sagaName)\n      .flatMap(x => sagaHandler(x.payload))\n      .map(result => {\n        // emit the result back to the app dispatcher for time travel.\n        setTimeout(() => AppDispatcher.emit({channel, actionType: `${sagaName}Result`, payload: result}), 0)\n        return result\n      })\n}\n\nfunction _bindSagaHandlers(channel, ActionTypes, SagaHandlers) {\n\n  return AppDispatcher =>\n\n    Object.keys(ActionTypes).reduce(\n      (observables, saga) => {\n\n        const handler = SagaHandlers[saga]\n        const observable = bindSagaHandler(channel, saga, handler)(AppDispatcher)\n\n        return Object.assign(observables, {[saga]: observable})\n      },\n      {}\n    )\n}\n\nfunction _bindSagaResultObservables(sagas) {\n\n  return Object.keys(sagas).reduce(\n    (observables, saga) => Object.assign(observables, {[`${saga}ResultObservable`]: sagas[saga]}),\n    {}\n  )\n}\n\n/**\n * Sagas are primarily used for handling ajax workflows.\n *\n * @param {String} channel - the name of the saga collection\n * @param {Map<String,*>} ActionTypes - the names of the action types (aka side effects) these sagas handle\n * @param {Map<ActionType,Function>} SagaActionFunctions - (optional) map of action functions indexed by\n * ActionType. Like a store's action functions, these functions can be used to initiate a saga. Note\n * that if you include one action function, then every ActionType must have a corresponding action function.\n * @param {Function} SagaHandlersFn - higher order function with signature `({sagas})=>SagaHandlers` that\n * accepts the `sagas` interface object and returns the SagaHandlers. The SagaHandlers are a map of\n * functions indexed by ActionType i.e, Map<ActionType,Function>.\n * @return {Saga} higher order function that creates the saga.\n */\nexport default function createSagas({channel, ActionTypes, SagaActionFunctions = {}, SagaHandlersFn}) {\n\n  assert(typeof channel === 'string', 'Needs a channel and it needs to be a string')\n  assert(ActionTypes, 'Need ActionTypes')\n  assert(SagaHandlersFn, 'Need SagaHandlersFn')\n  assert(typeof SagaHandlersFn === 'function', 'SagaHandlersFn should be a higher order function')\n\n  return ({AppDispatcher, sagaInterface}) => {\n\n    /* eslint-disable new-cap */\n    const SagaHandlers = SagaHandlersFn({sagas: sagaInterface})\n    /* eslint-enable */\n\n    //every side effect must map to an action function and handler\n    Object.keys(ActionTypes).forEach(action => {\n      if (SagaActionFunctions) {\n        assert(\n          SagaActionFunctions[action],\n          `Channel ${channel} is missing side effect action function \"${action}\"`\n        )\n      }\n      assert(SagaHandlers[action], `Channel ${channel} is missing side effect handler \"${action}\"`)\n    })\n\n    const observables = _bindSagaHandlers(channel, ActionTypes, SagaHandlers)(AppDispatcher)\n\n    return {\n      name: channel,\n      observables,\n      actionFunctions: bindActionFunctions(ActionTypes, SagaActionFunctions)(AppDispatcher),\n      resultObservables: _bindSagaResultObservables(observables)\n    }\n  }\n}\n"]}