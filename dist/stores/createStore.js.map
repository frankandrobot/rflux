{"version":3,"sources":["stores/createStore.js"],"names":[],"mappings":"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","file":"createStore.js","sourcesContent":["import cast from '../internal/cast'\nimport assert from '../internal/assert'\n\nimport {StateWithSideEffects} from './StateWithSideEffects'\n\n\nfunction _bindActionFunctionToAppDispatcher(actionFunction) {\n\n  return AppDispatcher =>\n    (...args) => AppDispatcher.emit({...actionFunction(...args)})\n}\n\n/**\n * Returns a function that binds the action functions to the app dispatcher.\n * This way AppDispatcher isn't a hard-coded dependency.\n *\n * @param ActionFunctions\n * @returns {Function}\n * @private\n */\nexport function bindActionFunctions(Actions, ActionFunctions) {\n\n  return AppDispatcher =>\n\n    Object.keys(Actions).reduce(\n      (storeActions, action) => ({\n        ...storeActions,\n        [action]: _bindActionFunctionToAppDispatcher(ActionFunctions[action])(AppDispatcher)\n      }),\n      {}\n    )\n}\n\n/**\n * Returns a function that binds the action observables to the store observable.\n * Action observables can give you a fine grain view of a store's state.\n *\n * You always have the storeObservable which is the top-level state view of the entire store.\n *\n * @param ActionObservables\n * @returns {*}\n * @private\n */\nfunction _bindActionObservables(ActionObservables) {\n\n  return storeObservable =>\n\n    Object.keys(ActionObservables).reduce(\n      (total, observable) => Object.assign(total, {[observable]: ActionObservables[observable](storeObservable)}),\n      {}\n    )\n}\n\n/**\n * Returns a function that binds the AppDispatcher to the store observable.\n *\n * The store observable is made from the channel Reducers.\n * When an action comes in, it will call the corresponding reducer with the payload.\n *\n * Note: in order for this to work, every Action must have a Reducer of the same name\n *\n * @param channel\n * @param Actions\n * @param Reducers\n * @returns {Function}\n */\nfunction _bindStoreObservable(channel, Reducers) {\n\n  const initialState = new StateWithSideEffects(Reducers.initialState || {})\n\n  return AppDispatcher =>\n\n    AppDispatcher\n      .filter(x => x.channel === channel)\n      .scan(\n        (state, action) => {\n\n          const handler = Reducers[action.actionType]\n\n          if (!handler) {\n            throw new Error(`Channel ${channel} does not support ${action.actionType}`)\n          }\n\n          const result = payload => AppDispatcher.emit({channel, actionType: `${action.actionType}Result`, payload})\n\n          // always return a StateWithSideEffects\n          return cast(handler(state, action.payload, result), StateWithSideEffects)\n\n        },\n        initialState\n      )\n      .skip(1)\n}\n\nfunction _bindResultObservables(channel, Actions) {\n\n  return AppDispatcher =>\n\n    Object.keys(Actions).reduce(\n      (observables, action) => Object.assign(observables, {\n        [`${action}ResultObservable`]: AppDispatcher.filter(x => x.channel === channel && x.actionType === `${action}Result`)\n      }),\n      {}\n    )\n}\n\n/**\n * The \"store\" is just the public interface used by the app. It consists of:\n *\n * - action functions (ex: DocActions) - this is what you call to initiate a store update\n * - action observables (optional) (ex: DocActionObservables) - this is how you know the store update completed.\n * - store observable - the store state\n *\n * **In order for this to work, every action function and action observable must be globally unique.**\n *\n * This isn't hard to achieve as long as you:\n * 1. use the storeStateName in the action/observable. Ex: createDoc\n * 2. use the word \"observable\" in the observables. Ex: docObservable\n *\n * @param storeName\n * @param channel\n * @param Actions\n * @param Reducers\n * @param ActionFunctions\n * @param ActionObservables (optional) - you always get one for free... the observable that listens to the entire store\n * @returns {{}}\n */\nexport default function createStore(channel, {Actions, Reducers, ActionFunctions, ActionObservables}) {\n\n  ActionObservables = ActionObservables || {}\n\n  assert(typeof channel === 'string', 'Needs a channel and it needs to be a string')\n  assert(Actions, 'Need Actions')\n  assert(Reducers, 'Need Reducers')\n  assert(ActionFunctions, 'Need action functions')\n\n  //every action must have an action function and a reducer\n  Object.keys(Actions).forEach(action => {\n    assert(ActionFunctions[action], `Channel ${channel} is missing action function \"${action}\"`)\n    assert(Reducers[action], `Channel ${channel} is missing reducer \"${action}\"`)\n  })\n\n  //need an initial state; otherwise defaults to {}\n  if (!Reducers.initialState) {\n    console.warn(`Channel ${channel} doesn't have initialState`)\n  }\n\n  return AppDispatcher => {\n\n    const storeWithSideEffectsObservable = _bindStoreObservable(channel, Reducers)(AppDispatcher)\n    const storeObservable = storeWithSideEffectsObservable.map(x => x.state)\n\n    return {\n      name: channel,\n      observable: storeWithSideEffectsObservable,\n      store: {\n        ...bindActionFunctions(Actions, ActionFunctions)(AppDispatcher),\n        ..._bindActionObservables(ActionObservables)(storeObservable),\n        ..._bindResultObservables(channel, Actions)(AppDispatcher),\n        [`${channel}Observable`]: storeObservable\n      }\n    }\n  }\n}\n"]}