{"version":3,"sources":["stores/createStore.js"],"names":["bindActionFunctions","createStore","_bindActionFunctionToAppDispatcher","actionFunction","AppDispatcher","emit","Actions","ActionFunctions","Object","keys","reduce","storeActions","action","_bindActionObservables","ActionObservables","total","observable","assign","storeObservable","_createStoreObservable","channel","Reducers","initialState","filter","x","scan","stateWithSideEffects","reducer","actionType","Error","endOfSideEffects","payload","state","_createEndOfActionsObservables","observables","map","forEach","console","warn","storeWithSideEffectsObservable","name","store"],"mappings":"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","file":"createStore.js","sourcesContent":["import cast from '../internal/cast'\nimport assert from '../internal/assert'\n\nimport StateWithSideEffects from './StateWithSideEffects'\n\n\nfunction _bindActionFunctionToAppDispatcher(actionFunction) {\n\n  return AppDispatcher =>\n    (...args) => AppDispatcher.emit({...actionFunction(...args)})\n}\n\n/**\n * Takes a map of ActionFunctions indexed by Action and binds each to the\n * AppDispatcher. That is, when a bound function is called, it automatically\n * dispatches its message to the store.\n *\n * TODO global rename Action => ActionType\n *\n * **Note:**\n * 1. This method is actually a higher order function. It returns a function\n *    that accepts the AppDispatcher object as a parameter. This way, the\n *    AppDispatcher is not hard-coded dependency.\n *\n * @param {Map<String,Boolean>} Actions\n * @param {Map<Action,Function>} ActionFunctions\n * @returns {Function} a function that binds the action functions to the app dispatcher\n */\nexport function bindActionFunctions(Actions, ActionFunctions) {\n\n  return AppDispatcher =>\n\n    Object.keys(Actions).reduce(\n      (storeActions, action) => ({\n        ...storeActions,\n        [action]: _bindActionFunctionToAppDispatcher(ActionFunctions[action])(AppDispatcher)\n      }),\n      {}\n    )\n}\n\n/**\n * @deprecated You rarely (really) need a *pre-bound* selector (emphasis:\n * \"pre-bound\"). For this reason, these are deprecated.\n *\n * Takes a map of ActionObservables *not necessarily indexed by Action* and binds each\n * to the StoreObservable. The StoreObservable is the store's state, wrapped in a\n * Kefir stream (otherwise known as an *observable*).\n *\n * Since the StoreObservable represents the state, an ActionObservable is a way of\n * observing (aka \"selecting\") arbitrary parts of the state tree.\n *\n * **Note:**\n * 1. This method is actually a higher order function. It returns a function\n *    that accepts a StoreObservable object as a parameter. This way, the\n *    StoreObservable is not hard-coded dependency.\n *\n * TODO global rename StoreObservable => StateObservable\n * TODO global rename ActionObservable => SelectionObservable\n *\n * @param {Map<String,Observable>} ActionObservables\n * @returns {Function} a function that binds the action observables to the store observable\n * @private\n */\nfunction _bindActionObservables(ActionObservables) {\n\n  return storeObservable =>\n\n    Object.keys(ActionObservables).reduce(\n      (total, observable) => Object.assign(\n        total,\n        {[observable]: ActionObservables[observable](storeObservable)}\n      ),\n      {}\n    )\n}\n\n/**\n * Creates the store's state observable using the given channel name.\n *\n * When an action comes in, it will call the corresponding reducer with the payload,\n * and pass the new state to the observable.\n *\n * Every reducer is called with these parameters:\n * 1. the current state\n * 2. the action payload\n * 3. a `endOfSideEffects` function that can be used to report the end of all the\n * side effects.\n *\n * In addition to updating the state, every reducer can also dispatch side\n * effects---which are just messages that are handled by other reducers or sagas. By\n * using the result of the `endOfSideEffects` function as the last side effect, it is\n * possible to tell when the entire reducer workflow completes... or so that's the\n * idea.\n *\n * Each reducer has this signature:\n *\n * ```\n * (state:StoreState, payload:Payload, endOfSideEffects:Payload => Message)\n * => StateWithSideEffects\n * ```\n *\n * TODO sideEffectResult may not actually fire correctly, specially when side effects\n * are handled by async sagas.\n *\n * **Notes:**\n * 1. Every Action must have a corresponding Reducer.\n * 2. This method is actually a higher order function. It returns a function\n *    that accepts an AppDispatcher object as a parameter. This way, the\n *    AppDispatcher is not hard-coded dependency.\n *\n * @param {String} channel\n * @param {Map<Action,Function>} Reducers\n * @returns {Function} a function that creates the store's state observable.\n */\nfunction _createStoreObservable(channel, Reducers) {\n\n  const initialState = new StateWithSideEffects(Reducers.initialState || {})\n\n  return AppDispatcher =>\n\n    AppDispatcher\n      .filter(x => x.channel === channel)\n      .scan(\n        (stateWithSideEffects, action) => {\n\n          const reducer = Reducers[action.actionType]\n\n          if (!reducer) {\n            throw new Error(`Channel ${channel} does not support ${action.actionType}`)\n          }\n\n          const endOfSideEffects = payload => ({\n            channel: `${channel}Result`,\n            actionType: `${action.actionType}Result`,\n            payload\n          })\n\n          // always return a StateWithSideEffects (code hardening)\n          return cast(\n            reducer(stateWithSideEffects.state, action.payload, endOfSideEffects),\n            StateWithSideEffects\n          )\n        },\n        initialState\n      )\n}\n\n\n/**\n * The idea is that you can use these observables to observe the end of a reducer +\n * side effects.\n * @param {String} channel\n * @param {Map<String,*>} Actions\n * @returns {Function} function that binds AppDispatcher to the observables\n * @private\n */\nfunction _createEndOfActionsObservables(channel, Actions) {\n\n  return AppDispatcher =>\n\n    Object.keys(Actions).reduce(\n      (observables, action) => Object.assign(\n        observables,\n        {\n          [`${action}ResultObservable`]:\n            AppDispatcher\n              .filter(x =>\n              x.channel === `${channel}Result` && x.actionType === `${action}Result`)\n              .map(x => x.payload)\n        }\n      ),\n      {}\n    )\n}\n\n/* eslint-disable no-console */\n/**\n * The store consists of\n * - the channel name\n * - the state observable\n * - bound (aka \"live\") action functions\n * - bound state selectors (which will probably be deprecated in a future release)\n *\n * It is created from a map of the ActionTypes. Each ActionType has a corresponding\n * reducer, which handles incoming messages. Each ActionType also has a corresponding\n * ActionFunction that's used to dispatch messages.\n *\n * One catch is that the *names* of the ActionFunctions and the ActionObservables must\n * be globally unique. This isn't hard to achieve as long as you:\n *\n * 1. use the channel name in the action/observable. Ex: createDoc\n * 2. use the word \"observable\" in the observables. Ex: docObservable\n *\n * @param {String} channel\n * @param {Map<String,*>} Actions - map of action type constants\n * @param {Map<Action,Function>} Reducers - map of reducers, indexed by Action.\n * Additionally, reducers have an `initialState` property.\n * @param {Map<Action,Function>} ActionFunctions - map of action functions, indexed by\n * Action\n * @param {Map<String,Function>} ActionObservables (optional) - higher order functions\n * that take the StoreObservable as input and return an observable that selects parts\n * of the state tree. **This will probably be deprecated.**\n * @returns {Function} that binds the store to the app dispatcher\n */\nexport default function createStore(\n  channel,\n  {Actions, Reducers, ActionFunctions, ActionObservables}) {\n\n  ActionObservables = ActionObservables || {}\n\n  assert(typeof channel === 'string', 'Needs a channel and it needs to be a string')\n  assert(Actions, 'Need Actions')\n  assert(Reducers, 'Need Reducers')\n  assert(ActionFunctions, 'Need action functions')\n\n  //every action must have an action function and a reducer\n  Object.keys(Actions).forEach(action => {\n    assert(\n      ActionFunctions[action],\n      `Channel ${channel} is missing action function \"${action}\"`\n    )\n    assert(Reducers[action], `Channel ${channel} is missing reducer \"${action}\"`)\n  })\n\n  //need an initial state; otherwise defaults to {}\n  if (!Reducers.initialState) {\n    console.warn(`Channel ${channel} doesn't have initialState`)\n  }\n\n  return AppDispatcher => {\n\n    const storeWithSideEffectsObservable =\n      _createStoreObservable(channel, Reducers)(AppDispatcher)\n    const storeObservable = storeWithSideEffectsObservable.map(x => x.state)\n\n    return {\n      name: channel,\n      observable: storeWithSideEffectsObservable,\n      store: {\n        ...bindActionFunctions(Actions, ActionFunctions)(AppDispatcher),\n        ..._bindActionObservables(ActionObservables)(storeObservable),\n        /**\n         * @deprecated\n         */\n        ..._createEndOfActionsObservables(channel, Actions)(AppDispatcher),\n        [`${channel}Observable`]: storeObservable\n      }\n    }\n  }\n}\n"]}