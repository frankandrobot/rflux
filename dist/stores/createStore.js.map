{"version":3,"sources":["stores/createStore.js"],"names":["bindActionFunctions","createStore","_bindActionFunctionToAppDispatcher","actionFunction","AppDispatcher","emit","ActionTypes","ActionFunctions","Object","keys","reduce","storeActions","action","_bindActionObservables","ActionObservables","total","observable","assign","storeObservable","_createStoreStateObservable","channel","Reducers","filter","x","scan","stateWithSideEffects","reducer","actionType","Error","endOfSideEffects","payload","state","initialState","_createEndOfActionsObservables","observables","map","forEach","console","warn","stateWithSideEffectsObservable","stateObservable","name","store"],"mappings":"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","file":"createStore.js","sourcesContent":["import cast from '../internal/cast'\nimport assert from '../internal/assert'\n\nimport StateWithSideEffects from './StateWithSideEffects'\nimport {state} from './StateWithSideEffects'\n\n\nfunction _bindActionFunctionToAppDispatcher(actionFunction) {\n\n  return AppDispatcher =>\n    (...args) => AppDispatcher.emit({...actionFunction(...args)})\n}\n\n/**\n * Takes a map of ActionFunctions indexed by ActionType and binds each to the\n * AppDispatcher. That is, when a bound function is called, it automatically\n * dispatches its message to the store.\n *\n * **Note:**\n * 1. This method is actually a higher order function. It returns a function\n *    that accepts the AppDispatcher object as a parameter. This way, the\n *    AppDispatcher is not hard-coded dependency.\n *\n * @param {Map<String,Boolean>} ActionTypes\n * @param {Map<ActionType,Function>} ActionFunctions\n * @returns {Function} a function that binds the action functions to the app dispatcher\n */\nexport function bindActionFunctions(ActionTypes, ActionFunctions) {\n\n  return AppDispatcher =>\n\n    Object.keys(ActionTypes).reduce(\n      (storeActions, action) => ({\n        ...storeActions,\n        [action]: _bindActionFunctionToAppDispatcher(ActionFunctions[action])(AppDispatcher)\n      }),\n      {}\n    )\n}\n\n/**\n * @deprecated You rarely (really) need a *pre-bound* selector (emphasis:\n * \"pre-bound\"). For this reason, these are deprecated.\n *\n * Takes a map of ActionObservables *not necessarily indexed by ActionType* and binds each\n * to the StoreStateObservable. The StoreStateObservable is the store's state, wrapped in a\n * Kefir stream (otherwise known as an *observable*).\n *\n * Since the StoreStateObservable represents the state, an ActionObservable is a way of\n * observing (aka \"selecting\") arbitrary parts of the state tree.\n *\n * **Note:**\n * 1. This method is actually a higher order function. It returns a function\n *    that accepts a StoreStateObservable object as a parameter. This way, the\n *    StoreStateObservable is not hard-coded dependency.\n *\n * TODO global rename StateObservable => StateObservable\n * TODO global rename ActionObservable => SelectionObservable\n *\n * @param {Map<String,Observable>} ActionObservables\n * @returns {Function} a function that binds the action observables to the store observable\n * @private\n */\nfunction _bindActionObservables(ActionObservables) {\n\n  return storeObservable =>\n\n    Object.keys(ActionObservables).reduce(\n      (total, observable) => Object.assign(\n        total,\n        {[observable]: ActionObservables[observable](storeObservable)}\n      ),\n      {}\n    )\n}\n\n/**\n * Creates the store's state observable using the given channel name.\n *\n * When an action comes in, it will call the corresponding reducer with the payload,\n * and pass the new state to the observable.\n *\n * Every reducer is called with these parameters:\n * 1. the current state\n * 2. the action payload\n * 3. a `endOfSideEffects` function that can be used to report the end of all the\n * side effects.\n *\n * In addition to updating the state, every reducer can also dispatch side\n * effects---which are just messages that are handled by other reducers or sagas. By\n * using the result of the `endOfSideEffects` function as the last side effect, it is\n * possible to tell when the entire reducer workflow completes... or so that's the\n * idea.\n *\n * Each reducer has this signature:\n *\n * ```\n * (state:StoreState, payload:Payload, endOfSideEffects:Payload => Message)\n * => StateWithSideEffects\n * ```\n *\n * TODO sideEffectResult may not actually fire correctly, specially when side effects\n * are handled by async sagas.\n *\n * **Notes:**\n * 1. Every ActionType must have a corresponding Reducer.\n * 2. This method is actually a higher order function. It returns a function\n *    that accepts an AppDispatcher object as a parameter. This way, the\n *    AppDispatcher is not hard-coded dependency.\n *\n * @param {String} channel\n * @param {Map<ActionType,Function>} Reducers\n * @returns {Function} a function that creates the store's state observable.\n */\nfunction _createStoreStateObservable(channel, Reducers) {\n\n  return AppDispatcher =>\n\n    AppDispatcher\n      .filter(x => x && x.channel === channel)\n      .scan(\n        (stateWithSideEffects, action) => {\n\n          const reducer = Reducers[action.actionType]\n\n          if (!reducer) {\n            throw new Error(`Channel ${channel} does not support ${action.actionType}`)\n          }\n\n          const endOfSideEffects = payload => ({\n            channel: `${channel}Result`,\n            actionType: `${action.actionType}Result`,\n            payload\n          })\n\n          // always return a StateWithSideEffects (code hardening)\n          return cast(\n            reducer(stateWithSideEffects.state, action.payload, endOfSideEffects),\n            StateWithSideEffects\n          )\n        },\n        state(Reducers.initialState || {})\n        )\n}\n\n\n/**\n * The idea is that you can use these observables to observe the end of a reducer +\n * side effects.\n * @param {String} channel\n * @param {Map<String,*>} ActionTypes\n * @returns {Function} function that binds AppDispatcher to the observables\n * @private\n */\nfunction _createEndOfActionsObservables(channel, ActionTypes) {\n\n  return AppDispatcher =>\n\n    Object.keys(ActionTypes).reduce(\n      (observables, action) => Object.assign(\n        observables,\n        {\n          [`${action}ResultObservable`]:\n            AppDispatcher\n              .filter(x =>\n              x.channel === `${channel}Result` && x.actionType === `${action}Result`)\n              .map(x => x.payload)\n        }\n      ),\n      {}\n    )\n}\n\n/* eslint-disable no-console */\n/**\n * The store consists of\n * - the channel name\n * - the state observable\n * - bound (aka \"live\") action functions\n * - bound state selectors (which will probably be deprecated in a future release)\n *\n * It is created from a map of the ActionTypes. Each ActionType has a corresponding\n * reducer, which handles incoming messages. Each ActionType also has a corresponding\n * ActionFunction that's used to dispatch messages.\n *\n * One catch is that the *names* of the ActionFunctions and the ActionObservables must\n * be globally unique. This isn't hard to achieve as long as you:\n *\n * 1. use the channel name in the action/observable. Ex: createDoc\n * 2. use the word \"observable\" in the observables. Ex: docObservable\n *\n * @param {String} channel\n * @param {Map<String,*>} ActionTypes - map of action type constants\n * @param {Map<ActionType,Function>} Reducers - map of reducers, indexed by ActionType.\n * Additionally, reducers have an `initialState` property.\n * @param {Map<ActionType,Function>} ActionFunctions - map of action functions, indexed by\n * ActionType\n * @param {Map<String,Function>} ActionObservables (optional) - higher order functions\n * that take the StoreStateObservable as input and return an observable that selects parts\n * of the state tree. **This will probably be deprecated.**\n * @returns {Function} that binds the store to the app dispatcher\n */\nexport default function createStore(\n  channel,\n  {ActionTypes, Reducers, ActionFunctions, ActionObservables}) {\n\n  ActionObservables = ActionObservables || {}\n\n  assert(typeof channel === 'string', 'Needs a channel and it needs to be a string')\n  assert(ActionTypes, 'Need ActionTypes')\n  assert(Reducers, 'Need Reducers')\n  assert(ActionFunctions, 'Need action functions')\n\n  //every action must have an action function and a reducer\n  Object.keys(ActionTypes).forEach(action => {\n    assert(\n      ActionFunctions[action],\n      `Channel ${channel} is missing action function \"${action}\"`\n    )\n    assert(Reducers[action], `Channel ${channel} is missing reducer \"${action}\"`)\n  })\n\n  //need an initial state; otherwise defaults to {}\n  if (!Reducers.initialState) {\n    console.warn(`Channel ${channel} doesn't have initialState`)\n  }\n\n  return AppDispatcher => {\n\n    const stateWithSideEffectsObservable =\n      _createStoreStateObservable(channel, Reducers)(AppDispatcher)\n    const stateObservable = stateWithSideEffectsObservable.map(x => x.state)\n\n    return {\n      name: channel,\n      stateWithSideEffectsObservable,\n      store: {\n        ...bindActionFunctions(ActionTypes, ActionFunctions)(AppDispatcher),\n        ..._bindActionObservables(ActionObservables)(stateObservable),\n        /**\n         * @deprecated\n         */\n        ..._createEndOfActionsObservables(channel, ActionTypes)(AppDispatcher),\n        [`${channel}Observable`]: stateObservable\n      }\n    }\n  }\n}\n"]}