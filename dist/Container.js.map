{"version":3,"sources":["Container.js"],"names":[],"mappings":";;;;;;;;;;AACA;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAiDqB,S;;;AAEnB,qBAAY,KAAZ,EAAmB;AAAA;;AAAA,wFAEX,KAFW;AAGlB;;;;yCAEoB;;AAEnB,WAAK,WAAL,GAAmB,aAAa,KAAK,KAAlB,CAAnB;AACA,wBAAkB,IAAlB,EAAwB,KAAK,KAA7B;AACD;;;8CAEyB,S,EAAW;;AAEnC,WAAK,WAAL,GAAmB,aAAa,SAAb,CAAnB;;;AAGA,mBAAa,KAAK,WAAlB,EAA+B,KAAK,SAApC;;;AAGA,wBAAkB,IAAlB,EAAwB,SAAxB;AACD;;;2CAEsB;;AAErB,mBAAa,KAAK,WAAlB,EAA+B,KAAK,SAApC;AACD;;;6BAEQ;AAAA;;AAEP;AACE,cAAM,KAAK,KAAL,CAAW,QAAX,CAAoB;AAD5B,+BAEG,UAFH,EAEgB,OAAO,GAAP,CAAW,eAAX,CAFhB,+CAGa,KAAK,KAHlB,EAG4B,KAAK,WAHjC;AAKD;;;;EApCoC,gBAAM,S;;kBAAxB,S;;;AAuCrB,SAAS,iBAAT,CAA2B,SAA3B,EAAsC,KAAtC,EAA6C;;AAE3C,YAAU,WAAV,GAAwB,aAAa,KAAb,CAAxB;AACA,YAAU,SAAV,GAAsB,WAAW,SAAX,EAAsB,UAAU,WAAhC,CAAtB;AACA,YAAU,QAAV,CACE,MAAM,QAAN,CAAe,IAAf,CAAoB,YAApB,IAAoC,EADtC,EAEE;AAAA,WAAM,WAAW,UAAU,WAArB,EAAkC,UAAU,SAA5C,CAAN;AAAA,GAFF;AAID;;AAED,SAAS,YAAT,CAAsB,KAAtB,EAA6B;;AAE3B,SAAO,OAAO,IAAP,CAAY,KAAZ,EACF,MADE,CACK;AAAA,WAAQ,8BAAa,MAAM,IAAN,CAAb,CAAR;AAAA,GADL,EAEF,GAFE,CAEE;AAAA,WAAS,EAAC,UAAU,IAAX,EAAiB,YAAY,MAAM,IAAN,CAA7B,EAAT;AAAA,GAFF,KAE0D,EAFjE;AAGD;;;;;;;;;AASD,SAAS,UAAT,CAAoB,SAApB,EAA+B,WAA/B,EAA4C;;AAE1C,SAAO,YAAY,GAAZ,CAAgB;AAAA,WAAO,eAAO;AACnC,gBAAU,QAAV,qBAAqB,IAAI,QAAzB,EAAoC,GAApC;AACD,KAFsB;AAAA,GAAhB,CAAP;AAGD;;AAED,SAAS,UAAT,CAAoB,WAApB,EAAiC,SAAjC,EAA4C;;AAE1C,cAAY,OAAZ,CAAoB,UAAC,GAAD,EAAM,CAAN;AAAA,WAAY,IAAI,UAAJ,CAAe,OAAf,CAAuB,UAAU,CAAV,CAAvB,CAAZ;AAAA,GAApB;AACD;;AAED,SAAS,YAAT,CAAsB,WAAtB,EAAmC,SAAnC,EAA8C;;AAE5C,cAAY,OAAZ,CAAoB,UAAC,GAAD,EAAM,CAAN;AAAA,WAAY,IAAI,UAAJ,CAAe,QAAf,CAAwB,UAAU,CAAV,CAAxB,CAAZ;AAAA,GAApB;AACD;;AAED,SAAS,YAAT,CAAsB,KAAtB,EAA6B;;AAE3B,SAAO,OAAO,IAAP,CAAY,KAAZ,EACJ,MADI,CACG;AAAA,WAAQ,CAAC,8BAAa,MAAM,IAAN,CAAb,CAAD,IAA8B,SAAS,UAA/C;AAAA,GADH,EAEJ,MAFI,CAEG,UAAC,KAAD,EAAQ,IAAR;AAAA,WAAiB,OAAO,MAAP,CAAc,KAAd,sBAAuB,IAAvB,EAA8B,MAAM,IAAN,CAA9B,EAAjB;AAAA,GAFH,EAEiE,EAFjE,CAAP;AAGD","file":"Container.js","sourcesContent":["/* eslint no-use-before-define:0 */\nimport React from 'react'\n\nimport {isObservable} from './support/kefirUtils'\n\n\n/**\n * In the props you pass normal properties and observables.\n * The observables is where the magic is---for each observable, add a listener,\n * and set the state of the Container equal to the observed value.\n * For example, if props = {obs1: observable} and the observed values are a, b, c...,\n * then this.state.obs1 = a, b, c, ...\n * Container then passes this state to its child as props.\n *\n * There are several ways to solve the problem of passing observables to components:\n * 1. stores manage transient state\n * ```\n * const docStore = {\n *   docs: {},\n *   curDocUuid: null,\n  *  newDocUui: null\n * }\n * ```\n * in the above, the docStore manages curDocUuid and newDocUuid. This seems like a job for the app\n *\n * 2. pass transient state view props to child components.\n *    This option is problematic when a *stream* is a function of a prop.\n *    The reason is because with each prop change, the previous observers need to be killed.\n *\n *    That's obviously bad and including Container makes for a hard-to-use API\n *\n * ```\n * export function docObservable(docsObservable) {\n\n  return uuid =>\n    docsObservable\n      .map(state => state.docs[uuid])\n      .filter(doc => doc)\n  }\n  ```\n * 3. create observables that return parent objects, then pick out desired object in View.\n *    The obvious downside is that the internals of the state leaks out into the View.\n *    This makes it harder to refactor.\n *\n * 4. use other store action observables in an action observable.\n *    This is a variation of #3. Indirect relationships are bad for maintainability.\n *\n * 5. the last option is to use a variation of #3. *Create helper methods that pick out desired properties from a\n *    parent object*.\n *\n * @deprecated use createContainer\n */\nexport default class Container extends React.Component {\n\n  constructor(props) {\n\n    super(props)\n  }\n\n  componentWillMount() {\n\n    this.normalProps = _normalProps(this.props)\n    _setupObservables(this, this.props)\n  }\n\n  componentWillReceiveProps(nextProps) {\n\n    this.normalProps = _normalProps(nextProps)\n\n    //unsub previous\n    _unsubscribe(this.observables, this.callbacks)\n\n    //subscribe new\n    _setupObservables(this, nextProps)\n  }\n\n  componentWillUnmount() {\n\n    _unsubscribe(this.observables, this.callbacks)\n  }\n\n  render() {\n\n    return {\n      type: this.props.children.type,\n      ['$$typeof']: Symbol.for('react.element'),\n      props: {...this.state, ...this.normalProps}\n    }\n  }\n}\n\nfunction _setupObservables(component, props) {\n\n  component.observables = _observables(props)\n  component.callbacks = _callbacks(component, component.observables)\n  component.setState(\n    props.children.type.defaultProps || {},\n    () => _subscribe(component.observables, component.callbacks)\n  )\n}\n\nfunction _observables(props) {\n\n  return Object.keys(props)\n      .filter(prop => isObservable(props[prop]))\n      .map(prop => ({property: prop, observable: props[prop]})) || []\n}\n\n/**\n * a callback maps a \"val\" to the obj property on the Component state\n *\n * @param component\n * @param observables\n * @private\n */\nfunction _callbacks(component, observables) {\n\n  return observables.map(obj => val => {\n    component.setState({[obj.property]: val})\n  })\n}\n\nfunction _subscribe(observables, callbacks) {\n\n  observables.forEach((obj, i) => obj.observable.onValue(callbacks[i]))\n}\n\nfunction _unsubscribe(observables, callbacks) {\n\n  observables.forEach((obj, i) => obj.observable.offValue(callbacks[i]))\n}\n\nfunction _normalProps(props) {\n\n  return Object.keys(props)\n    .filter(prop => !isObservable(props[prop]) && prop !== 'children')\n    .reduce((total, prop) => Object.assign(total, {[prop]: props[prop]}), {})\n}\n"]}